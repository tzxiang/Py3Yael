# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _yael
else:
    import _yael

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _frompointer_and_acquire(aclass,ptr):
  r=aclass.frompointer(ptr)
  if r: r.this.acquire()
  return r


def fvec_from_pointer_long(ptr: "long") -> "float *":
    return _yael.fvec_from_pointer_long(ptr)

def fvec_to_pointer_long(fv: "float *") -> "long":
    return _yael.fvec_to_pointer_long(fv)

def dvec_from_pointer_long(ptr: "long") -> "double *":
    return _yael.dvec_from_pointer_long(ptr)

def dvec_to_pointer_long(fv: "double *") -> "long":
    return _yael.dvec_to_pointer_long(fv)
class DoubleArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.DoubleArray_swiginit(self, _yael.new_DoubleArray(nelements))
    __swig_destroy__ = _yael.delete_DoubleArray

    def __getitem__(self, index: "size_t") -> "double":
        return _yael.DoubleArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "double") -> "void":
        return _yael.DoubleArray___setitem__(self, index, value)

    def cast(self) -> "double *":
        return _yael.DoubleArray_cast(self)

    @staticmethod
    def frompointer(t: "double *") -> "DoubleArray *":
        return _yael.DoubleArray_frompointer(t)

    def plus(self, i: "long") -> "double *":
        return _yael.DoubleArray_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.DoubleArray_clear(self, n)

    def copyfrom(self, src: "double *", dest_ofs: "long", n: "long") -> "void":
        return _yael.DoubleArray_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.DoubleArray_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.DoubleArray_fromstring(self, obj)

# Register DoubleArray in _yael:
_yael.DoubleArray_swigregister(DoubleArray)
cvar = _yael.cvar

def DoubleArray_frompointer(t: "double *") -> "DoubleArray *":
    return _yael.DoubleArray_frompointer(t)


DoubleArray.aptr=DoubleArray.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(DoubleArray,ptr))

class FloatArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yael.delete_FloatArray

    def __getitem__(self, index: "size_t") -> "float":
        return _yael.FloatArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "float") -> "void":
        return _yael.FloatArray___setitem__(self, index, value)

    def cast(self) -> "float *":
        return _yael.FloatArray_cast(self)

    @staticmethod
    def frompointer(t: "float *") -> "FloatArray *":
        return _yael.FloatArray_frompointer(t)

    def plus(self, i: "long") -> "float *":
        return _yael.FloatArray_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.FloatArray_clear(self, n)

    def copyfrom(self, src: "float *", dest_ofs: "long", n: "long") -> "void":
        return _yael.FloatArray_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.FloatArray_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.FloatArray_fromstring(self, obj)

    def __init__(self, *args):
        _yael.FloatArray_swiginit(self, _yael.new_FloatArray(*args))

# Register FloatArray in _yael:
_yael.FloatArray_swigregister(FloatArray)

def FloatArray_frompointer(t: "float *") -> "FloatArray *":
    return _yael.FloatArray_frompointer(t)


FloatArray.aptr=FloatArray.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(FloatArray,ptr))

class IntArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _yael.delete_IntArray

    def __getitem__(self, index: "size_t") -> "int":
        return _yael.IntArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "int") -> "void":
        return _yael.IntArray___setitem__(self, index, value)

    def cast(self) -> "int *":
        return _yael.IntArray_cast(self)

    @staticmethod
    def frompointer(t: "int *") -> "IntArray *":
        return _yael.IntArray_frompointer(t)

    def plus(self, i: "long") -> "int *":
        return _yael.IntArray_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.IntArray_clear(self, n)

    def copyfrom(self, src: "int *", dest_ofs: "long", n: "long") -> "void":
        return _yael.IntArray_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.IntArray_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.IntArray_fromstring(self, obj)

    def __init__(self, *args):
        _yael.IntArray_swiginit(self, _yael.new_IntArray(*args))

# Register IntArray in _yael:
_yael.IntArray_swigregister(IntArray)

def IntArray_frompointer(t: "int *") -> "IntArray *":
    return _yael.IntArray_frompointer(t)


IntArray.aptr=IntArray.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(IntArray,ptr))

class bvec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.bvec_swiginit(self, _yael.new_bvec(nelements))
    __swig_destroy__ = _yael.delete_bvec

    def __getitem__(self, index: "size_t") -> "unsigned char":
        return _yael.bvec___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "unsigned char") -> "void":
        return _yael.bvec___setitem__(self, index, value)

    def cast(self) -> "unsigned char *":
        return _yael.bvec_cast(self)

    @staticmethod
    def frompointer(t: "unsigned char *") -> "bvec *":
        return _yael.bvec_frompointer(t)

    def plus(self, i: "long") -> "unsigned char *":
        return _yael.bvec_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.bvec_clear(self, n)

    def copyfrom(self, src: "unsigned char *", dest_ofs: "long", n: "long") -> "void":
        return _yael.bvec_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.bvec_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.bvec_fromstring(self, obj)

# Register bvec in _yael:
_yael.bvec_swigregister(bvec)

def bvec_frompointer(t: "unsigned char *") -> "bvec *":
    return _yael.bvec_frompointer(t)


bvec.aptr=bvec.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(bvec,ptr))

class int16vec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.int16vec_swiginit(self, _yael.new_int16vec(nelements))
    __swig_destroy__ = _yael.delete_int16vec

    def __getitem__(self, index: "size_t") -> "short":
        return _yael.int16vec___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "short") -> "void":
        return _yael.int16vec___setitem__(self, index, value)

    def cast(self) -> "short *":
        return _yael.int16vec_cast(self)

    @staticmethod
    def frompointer(t: "short *") -> "int16vec *":
        return _yael.int16vec_frompointer(t)

    def plus(self, i: "long") -> "short *":
        return _yael.int16vec_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.int16vec_clear(self, n)

    def copyfrom(self, src: "short *", dest_ofs: "long", n: "long") -> "void":
        return _yael.int16vec_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.int16vec_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.int16vec_fromstring(self, obj)

# Register int16vec in _yael:
_yael.int16vec_swigregister(int16vec)

def int16vec_frompointer(t: "short *") -> "int16vec *":
    return _yael.int16vec_frompointer(t)


int16vec.aptr=int16vec.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(int16vec,ptr))

class uint16vec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.uint16vec_swiginit(self, _yael.new_uint16vec(nelements))
    __swig_destroy__ = _yael.delete_uint16vec

    def __getitem__(self, index: "size_t") -> "unsigned short":
        return _yael.uint16vec___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "unsigned short") -> "void":
        return _yael.uint16vec___setitem__(self, index, value)

    def cast(self) -> "unsigned short *":
        return _yael.uint16vec_cast(self)

    @staticmethod
    def frompointer(t: "unsigned short *") -> "uint16vec *":
        return _yael.uint16vec_frompointer(t)

    def plus(self, i: "long") -> "unsigned short *":
        return _yael.uint16vec_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.uint16vec_clear(self, n)

    def copyfrom(self, src: "unsigned short *", dest_ofs: "long", n: "long") -> "void":
        return _yael.uint16vec_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.uint16vec_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.uint16vec_fromstring(self, obj)

# Register uint16vec in _yael:
_yael.uint16vec_swigregister(uint16vec)

def uint16vec_frompointer(t: "unsigned short *") -> "uint16vec *":
    return _yael.uint16vec_frompointer(t)


uint16vec.aptr=uint16vec.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(uint16vec,ptr))

class lvec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.lvec_swiginit(self, _yael.new_lvec(nelements))
    __swig_destroy__ = _yael.delete_lvec

    def __getitem__(self, index: "size_t") -> "long long":
        return _yael.lvec___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "long long") -> "void":
        return _yael.lvec___setitem__(self, index, value)

    def cast(self) -> "long long *":
        return _yael.lvec_cast(self)

    @staticmethod
    def frompointer(t: "long long *") -> "lvec *":
        return _yael.lvec_frompointer(t)

    def plus(self, i: "long") -> "long long *":
        return _yael.lvec_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.lvec_clear(self, n)

    def copyfrom(self, src: "long long *", dest_ofs: "long", n: "long") -> "void":
        return _yael.lvec_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.lvec_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.lvec_fromstring(self, obj)

# Register lvec in _yael:
_yael.lvec_swigregister(lvec)

def lvec_frompointer(t: "long long *") -> "lvec *":
    return _yael.lvec_frompointer(t)


lvec.aptr=lvec.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(lvec,ptr))

class UInt64Array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.UInt64Array_swiginit(self, _yael.new_UInt64Array(nelements))
    __swig_destroy__ = _yael.delete_UInt64Array

    def __getitem__(self, index: "size_t") -> "unsigned long long":
        return _yael.UInt64Array___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "unsigned long long") -> "void":
        return _yael.UInt64Array___setitem__(self, index, value)

    def cast(self) -> "unsigned long long *":
        return _yael.UInt64Array_cast(self)

    @staticmethod
    def frompointer(t: "unsigned long long *") -> "UInt64Array *":
        return _yael.UInt64Array_frompointer(t)

    def plus(self, i: "long") -> "unsigned long long *":
        return _yael.UInt64Array_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.UInt64Array_clear(self, n)

    def copyfrom(self, src: "unsigned long long *", dest_ofs: "long", n: "long") -> "void":
        return _yael.UInt64Array_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.UInt64Array_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.UInt64Array_fromstring(self, obj)

# Register UInt64Array in _yael:
_yael.UInt64Array_swigregister(UInt64Array)

def UInt64Array_frompointer(t: "unsigned long long *") -> "UInt64Array *":
    return _yael.UInt64Array_frompointer(t)


UInt64Array.aptr=UInt64Array.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(UInt64Array,ptr))

class IntPtrArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.IntPtrArray_swiginit(self, _yael.new_IntPtrArray(nelements))
    __swig_destroy__ = _yael.delete_IntPtrArray

    def __getitem__(self, index: "size_t") -> "int_pointer_t":
        return _yael.IntPtrArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "int_pointer_t") -> "void":
        return _yael.IntPtrArray___setitem__(self, index, value)

    def cast(self) -> "int_pointer_t *":
        return _yael.IntPtrArray_cast(self)

    @staticmethod
    def frompointer(t: "int_pointer_t *") -> "IntPtrArray *":
        return _yael.IntPtrArray_frompointer(t)

    def plus(self, i: "long") -> "int_pointer_t *":
        return _yael.IntPtrArray_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.IntPtrArray_clear(self, n)

    def copyfrom(self, src: "int_pointer_t *", dest_ofs: "long", n: "long") -> "void":
        return _yael.IntPtrArray_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.IntPtrArray_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.IntPtrArray_fromstring(self, obj)

# Register IntPtrArray in _yael:
_yael.IntPtrArray_swigregister(IntPtrArray)

def IntPtrArray_frompointer(t: "int_pointer_t *") -> "IntPtrArray *":
    return _yael.IntPtrArray_frompointer(t)


IntPtrArray.aptr=IntPtrArray.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(IntPtrArray,ptr))

class FloatPtrArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.FloatPtrArray_swiginit(self, _yael.new_FloatPtrArray(nelements))
    __swig_destroy__ = _yael.delete_FloatPtrArray

    def __getitem__(self, index: "size_t") -> "float_pointer_t":
        return _yael.FloatPtrArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "float_pointer_t") -> "void":
        return _yael.FloatPtrArray___setitem__(self, index, value)

    def cast(self) -> "float_pointer_t *":
        return _yael.FloatPtrArray_cast(self)

    @staticmethod
    def frompointer(t: "float_pointer_t *") -> "FloatPtrArray *":
        return _yael.FloatPtrArray_frompointer(t)

    def plus(self, i: "long") -> "float_pointer_t *":
        return _yael.FloatPtrArray_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.FloatPtrArray_clear(self, n)

    def copyfrom(self, src: "float_pointer_t *", dest_ofs: "long", n: "long") -> "void":
        return _yael.FloatPtrArray_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.FloatPtrArray_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.FloatPtrArray_fromstring(self, obj)

# Register FloatPtrArray in _yael:
_yael.FloatPtrArray_swigregister(FloatPtrArray)

def FloatPtrArray_frompointer(t: "float_pointer_t *") -> "FloatPtrArray *":
    return _yael.FloatPtrArray_frompointer(t)


FloatPtrArray.aptr=FloatPtrArray.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(FloatPtrArray,ptr))

class BytePtrArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements: "size_t"):
        _yael.BytePtrArray_swiginit(self, _yael.new_BytePtrArray(nelements))
    __swig_destroy__ = _yael.delete_BytePtrArray

    def __getitem__(self, index: "size_t") -> "byte_pointer_t":
        return _yael.BytePtrArray___getitem__(self, index)

    def __setitem__(self, index: "size_t", value: "byte_pointer_t") -> "void":
        return _yael.BytePtrArray___setitem__(self, index, value)

    def cast(self) -> "byte_pointer_t *":
        return _yael.BytePtrArray_cast(self)

    @staticmethod
    def frompointer(t: "byte_pointer_t *") -> "BytePtrArray *":
        return _yael.BytePtrArray_frompointer(t)

    def plus(self, i: "long") -> "byte_pointer_t *":
        return _yael.BytePtrArray_plus(self, i)

    def clear(self, n: "long") -> "void":
        return _yael.BytePtrArray_clear(self, n)

    def copyfrom(self, src: "byte_pointer_t *", dest_ofs: "long", n: "long") -> "void":
        return _yael.BytePtrArray_copyfrom(self, src, dest_ofs, n)

    def tostring(self, n: "long") -> "PyObject *":
        return _yael.BytePtrArray_tostring(self, n)

    def fromstring(self, obj: "PyObject *") -> "void":
        return _yael.BytePtrArray_fromstring(self, obj)

# Register BytePtrArray in _yael:
_yael.BytePtrArray_swigregister(BytePtrArray)

def BytePtrArray_frompointer(t: "byte_pointer_t *") -> "BytePtrArray *":
    return _yael.BytePtrArray_frompointer(t)


BytePtrArray.aptr=BytePtrArray.acquirepointer=staticmethod(lambda ptr: _frompointer_and_acquire(BytePtrArray,ptr))



fvec=FloatArray
dvec=DoubleArray
ivec=IntArray


def knn_full(distance_type: "int", nq: "int", nb: "int", d: "int", k: "int", b: "float const *", q: "float const *", b_weights: "float const *", assign: "int *", dis: "float *") -> "void":
    return _yael.knn_full(distance_type, nq, nb, d, k, b, q, b_weights, assign, dis)

def knn_full_thread(distance_type: "int", nq: "int", nb: "int", d: "int", k: "int", b: "float const *", q: "float const *", b_weights: "float const *", assign: "int *", dis: "float *", n_thread: "int") -> "void":
    return _yael.knn_full_thread(distance_type, nq, nb, d, k, b, q, b_weights, assign, dis, n_thread)

def nn(n: "int", nb: "int", d: "int", b: "float const *", v: "float const *", assign: "int *") -> "double":
    return _yael.nn(n, nb, d, b, v, assign)

def nn_thread(n: "int", nb: "int", d: "int", b: "float const *", v: "float const *", assign: "int *", n_thread: "int") -> "double":
    return _yael.nn_thread(n, nb, d, b, v, assign, n_thread)

def knn(n: "int", nb: "int", d: "int", k: "int", b: "float const *", v: "float const *", assign: "int *") -> "float *":
    return _yael.knn(n, nb, d, k, b, v, assign)

def knn_thread(nq: "int", nb: "int", d: "int", k: "int", b: "float const *", v: "float const *", assign: "int *", n_thread: "int") -> "float *":
    return _yael.knn_thread(nq, nb, d, k, b, v, assign, n_thread)

def knn_reorder_shortlist(n: "int", nb: "int", d: "int", k: "int", b: "float const *", v: "float const *", idx: "int *", dis: "float *") -> "void":
    return _yael.knn_reorder_shortlist(n, nb, d, k, b, v, idx, dis)

def knn_recompute_exact_dists(n: "int", nb: "int", d: "int", k: "int", b: "float const *", v: "float const *", label0: "int", kp: "int *", idx: "int const *", dis: "float *") -> "void":
    return _yael.knn_recompute_exact_dists(n, nb, d, k, b, v, label0, kp, idx, dis)

def compute_cross_distances(d: "int", na: "int", nb: "int", a: "float const *", b: "float const *", dist2: "float *") -> "void":
    return _yael.compute_cross_distances(d, na, nb, a, b, dist2)

def compute_cross_distances_nonpacked(d: "int", na: "int", nb: "int", a: "float const *", lda: "int", b: "float const *", ldb: "int", dist2: "float *", ldd: "int") -> "void":
    return _yael.compute_cross_distances_nonpacked(d, na, nb, a, lda, b, ldb, dist2, ldd)

def compute_cross_distances_thread(d: "int", na: "int", nb: "int", a: "float const *", b: "float const *", dist2: "float *", nt: "int") -> "void":
    return _yael.compute_cross_distances_thread(d, na, nb, a, b, dist2, nt)

def compute_cross_distances_alt(distance_type: "int", d: "int", na: "int", nb: "int", a: "float const *", b: "float const *", dist2: "float *") -> "void":
    return _yael.compute_cross_distances_alt(distance_type, d, na, nb, a, b, dist2)

def compute_cross_distances_alt_nonpacked(distance_type: "int", d: "int", na: "int", nb: "int", a: "float const *", lda: "int", b: "float const *", ldb: "int", dist2: "float *", ldd: "int") -> "void":
    return _yael.compute_cross_distances_alt_nonpacked(distance_type, d, na, nb, a, lda, b, ldb, dist2, ldd)

def compute_cross_distances_alt_thread(distance_type: "int", d: "int", na: "int", nb: "int", a: "float const *", b: "float const *", dist2: "float *", nt: "int") -> "void":
    return _yael.compute_cross_distances_alt_thread(distance_type, d, na, nb, a, b, dist2, nt)

def compute_distances_1(d: "int", nb: "int", a: "float const *", b: "float const *", dist2: "float *") -> "void":
    return _yael.compute_distances_1(d, nb, a, b, dist2)

def compute_distances_1_nonpacked(d: "int", nb: "int", a: "float const *", b: "float const *", ldb: "int", dist2: "float *") -> "void":
    return _yael.compute_distances_1_nonpacked(d, nb, a, b, ldb, dist2)

def compute_distances_1_thread(d: "int", nb: "int", a: "float const *", b: "float const *", dist2: "float *", n_thread: "int") -> "void":
    return _yael.compute_distances_1_thread(d, nb, a, b, dist2, n_thread)

def compute_distances_1_nonpacked_thread(d: "int", nb: "int", a: "float const *", b: "float const *", ldb: "int", dist2: "float *", n_thread: "int") -> "void":
    return _yael.compute_distances_1_nonpacked_thread(d, nb, a, b, ldb, dist2, n_thread)
KMEANS_QUIET = _yael.KMEANS_QUIET
KMEANS_INIT_BERKELEY = _yael.KMEANS_INIT_BERKELEY
KMEANS_NORMALIZE_CENTS = _yael.KMEANS_NORMALIZE_CENTS
KMEANS_INIT_RANDOM = _yael.KMEANS_INIT_RANDOM
KMEANS_INIT_USER = _yael.KMEANS_INIT_USER
KMEANS_L1 = _yael.KMEANS_L1
KMEANS_CHI2 = _yael.KMEANS_CHI2

def kmeans(d: "int", n: "int", k: "int", niter: "int", v: "float const *", flags: "int", seed: "long", redo: "int", centroids: "float *", dis: "float *", assign: "int *", nassign: "int *") -> "float":
    return _yael.kmeans(d, n, k, niter, v, flags, seed, redo, centroids, dis, assign, nassign)

def clustering_kmeans(n: "int", d: "int", points: "float const *", k: "int", nb_iter_max: "int", normalize: "double") -> "float *":
    return _yael.clustering_kmeans(n, d, points, k, nb_iter_max, normalize)

def clustering_kmeans_assign(n: "int", d: "int", points: "float const *", k: "int", nb_iter_max: "int", normalize: "double") -> "int **":
    return _yael.clustering_kmeans_assign(n, d, points, k, nb_iter_max, normalize)

def clustering_kmeans_assign_with_score(n: "int", d: "int", points: "float const *", k: "int", nb_iter_max: "int", normalize: "double", n_thread: "int", score_out: "double *") -> "int **":
    return _yael.clustering_kmeans_assign_with_score(n, d, points, k, nb_iter_max, normalize, n_thread, score_out)
class hkm_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nlevel = property(_yael.hkm_t_nlevel_get, _yael.hkm_t_nlevel_set)
    bf = property(_yael.hkm_t_bf_get, _yael.hkm_t_bf_set)
    k = property(_yael.hkm_t_k_get, _yael.hkm_t_k_set)
    d = property(_yael.hkm_t_d_get, _yael.hkm_t_d_set)
    centroids = property(_yael.hkm_t_centroids_get, _yael.hkm_t_centroids_set)

    def __init__(self):
        _yael.hkm_t_swiginit(self, _yael.new_hkm_t())
    __swig_destroy__ = _yael.delete_hkm_t

# Register hkm_t in _yael:
_yael.hkm_t_swigregister(hkm_t)


def hkm_learn(n: "int", d: "int", nlevel: "int", bf: "int", v: "float const *", nb_iter_max: "int", nt: "int", verbose: "int") -> "int **":
    return _yael.hkm_learn(n, d, nlevel, bf, v, nb_iter_max, nt, verbose)

def hkm_delete(hkm: "hkm_t") -> "void":
    return _yael.hkm_delete(hkm)

def hkm_quantize(hkm: "hkm_t", n: "int", v: "float const *", idx: "int *") -> "void":
    return _yael.hkm_quantize(hkm, n, v, idx)

def hkm_write(filename: "char const *", hkm: "hkm_t") -> "void":
    return _yael.hkm_write(filename, hkm)

def hkm_read(filename: "char const *") -> "hkm_t *":
    return _yael.hkm_read(filename)

def hkm_get_centroids(hkm: "hkm_t", l: "int", no: "int") -> "float *":
    return _yael.hkm_get_centroids(hkm, l, no)

def fvec_k_max(v: "float const *", n: "int", maxes: "int *", k: "int") -> "void":
    return _yael.fvec_k_max(v, n, maxes, k)

def fvec_k_min(v: "float const *", n: "int", mins: "int *", k: "int") -> "void":
    return _yael.fvec_k_min(v, n, mins, k)

def fvec_ranks_of(tab: "float const *", n: "int", vals: "float const *", nval: "int", minranks: "int *", maxranks: "int *") -> "void":
    return _yael.fvec_ranks_of(tab, n, vals, nval, minranks, maxranks)

def fvec_ranks_inc_of(tab: "float const *", n: "int", vals: "float const *", nval: "int", minranks: "int *", maxranks: "int *") -> "void":
    return _yael.fvec_ranks_inc_of(tab, n, vals, nval, minranks, maxranks)

def find_labels(labels: "int const *", nres: "int", ilabels: "int *", nilabels: "int") -> "void":
    return _yael.find_labels(labels, nres, ilabels, nilabels)

def fvec_min(f: "float const *", n: "long") -> "float":
    return _yael.fvec_min(f, n)

def ivec_min(f: "int const *", n: "long") -> "int":
    return _yael.ivec_min(f, n)

def fvec_max(f: "float const *", n: "long") -> "float":
    return _yael.fvec_max(f, n)

def ivec_max(f: "int const *", n: "long") -> "int":
    return _yael.ivec_max(f, n)

def fvec_arg_min(f: "float const *", n: "long") -> "int":
    return _yael.fvec_arg_min(f, n)

def fvec_arg_max(f: "float const *", n: "long") -> "int":
    return _yael.fvec_arg_max(f, n)

def fvec_median(f: "float *", n: "int") -> "float":
    return _yael.fvec_median(f, n)

def fvec_median_const(f: "float const *", n: "int") -> "float":
    return _yael.fvec_median_const(f, n)

def fvec_quantile(f: "float *", n: "int", q: "int") -> "float":
    return _yael.fvec_quantile(f, n, q)

def ivec_sort(tab: "int *", n: "int") -> "void":
    return _yael.ivec_sort(tab, n)

def ivec_sort_index(tab: "int const *", n: "int", perm: "int *") -> "void":
    return _yael.ivec_sort_index(tab, n, perm)

def ivec_invert_perm(perm: "int const *", n: "int", iperm: "int *") -> "void":
    return _yael.ivec_invert_perm(perm, n, iperm)

def fvec_sort(v: "float *", n: "int") -> "void":
    return _yael.fvec_sort(v, n)

def fvecs_sort(v: "float *", d: "int", n: "int") -> "void":
    return _yael.fvecs_sort(v, d, n)

def fvec_sort_index(tab: "float const *", n: "int", perm: "int *") -> "void":
    return _yael.fvec_sort_index(tab, n, perm)

def ivec_sort_by_permutation(v: "int *", order: "int const *", n: "int") -> "void":
    return _yael.ivec_sort_by_permutation(v, order, n)

def fvec_sort_by_permutation(v: "float *", order: "int const *", n: "int") -> "void":
    return _yael.fvec_sort_by_permutation(v, order, n)

def ivec_sorted_count_occurrences(v: "int const *", n: "int", val: "int") -> "int":
    return _yael.ivec_sorted_count_occurrences(v, n, val)

def ivec_sorted_find(v: "int const *", n: "int", val: "int") -> "int":
    return _yael.ivec_sorted_find(v, n, val)

def ivec_sorted_count_unique(v: "int const *", n: "int") -> "int":
    return _yael.ivec_sorted_count_unique(v, n)

def ivec_sorted_count_occurrences_multiple(v: "int const *", n: "int", vals: "int const *", nval: "int") -> "int":
    return _yael.ivec_sorted_count_occurrences_multiple(v, n, vals, nval)

def merge_ordered_sets(labels: "int const **", vals: "float const **", sizes: "int const *", k: "int") -> "float **":
    return _yael.merge_ordered_sets(labels, vals, sizes, k)

def compress_labels_by_disratio(labels: "int *", vals: "float const *", n: "int", ratio: "float") -> "int":
    return _yael.compress_labels_by_disratio(labels, vals, n, ratio)
class fbinheap_s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    val = property(_yael.fbinheap_s_val_get, _yael.fbinheap_s_val_set)
    label = property(_yael.fbinheap_s_label_get, _yael.fbinheap_s_label_set)
    k = property(_yael.fbinheap_s_k_get, _yael.fbinheap_s_k_set)
    maxk = property(_yael.fbinheap_s_maxk_get, _yael.fbinheap_s_maxk_set)

    def __init__(self):
        _yael.fbinheap_s_swiginit(self, _yael.new_fbinheap_s())
    __swig_destroy__ = _yael.delete_fbinheap_s

# Register fbinheap_s in _yael:
_yael.fbinheap_s_swigregister(fbinheap_s)


def fbinheap_new(maxk: "int") -> "struct fbinheap_s *":
    return _yael.fbinheap_new(maxk)

def fbinheap_sizeof(maxk: "int") -> "size_t":
    return _yael.fbinheap_sizeof(maxk)

def fbinheap_init(bh: "fbinheap_s", maxk: "int") -> "void":
    return _yael.fbinheap_init(bh, maxk)

def fbinheap_delete(bh: "fbinheap_s") -> "void":
    return _yael.fbinheap_delete(bh)

def fbinheap_reset(bh: "fbinheap_s") -> "void":
    return _yael.fbinheap_reset(bh)

def fbinheap_add(bh: "fbinheap_s", label: "int", val: "float") -> "void":
    return _yael.fbinheap_add(bh, label, val)

def fbinheap_pop(bh: "fbinheap_s") -> "void":
    return _yael.fbinheap_pop(bh)

def fbinheap_addn(bh: "fbinheap_s", n: "int", labels: "int const *", v: "float const *") -> "void":
    return _yael.fbinheap_addn(bh, n, labels, v)

def fbinheap_addn_label_range(bh: "fbinheap_s", n: "int", label0: "int", v: "float const *") -> "void":
    return _yael.fbinheap_addn_label_range(bh, n, label0, v)

def fbinheap_sort_labels(bh: "fbinheap_s", perm: "int *") -> "void":
    return _yael.fbinheap_sort_labels(bh, perm)

def fbinheap_sort_values(bh: "fbinheap_s", v: "float *") -> "void":
    return _yael.fbinheap_sort_values(bh, v)

def fbinheap_sort(bh: "fbinheap_s", labels: "int *", v: "float *") -> "void":
    return _yael.fbinheap_sort(bh, labels, v)

def fbinheap_sort_per_labels(bh: "fbinheap_s", labels: "int *", v: "float *") -> "void":
    return _yael.fbinheap_sort_per_labels(bh, labels, v)

def fbinheap_display(bh: "fbinheap_s") -> "void":
    return _yael.fbinheap_display(bh)
class abinheap_s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    val = property(_yael.abinheap_s_val_get, _yael.abinheap_s_val_set)
    label = property(_yael.abinheap_s_label_get, _yael.abinheap_s_label_set)
    k = property(_yael.abinheap_s_k_get, _yael.abinheap_s_k_set)
    maxk = property(_yael.abinheap_s_maxk_get, _yael.abinheap_s_maxk_set)
    labelsize = property(_yael.abinheap_s_labelsize_get, _yael.abinheap_s_labelsize_set)

    def __init__(self):
        _yael.abinheap_s_swiginit(self, _yael.new_abinheap_s())
    __swig_destroy__ = _yael.delete_abinheap_s

# Register abinheap_s in _yael:
_yael.abinheap_s_swigregister(abinheap_s)


def abinheap_new(maxk: "int", labelsize: "int") -> "struct abinheap_s *":
    return _yael.abinheap_new(maxk, labelsize)

def abinheap_sizeof(maxk: "int", labelsize: "int") -> "size_t":
    return _yael.abinheap_sizeof(maxk, labelsize)

def abinheap_init(bh: "abinheap_s", maxk: "int", labelsize: "int") -> "void":
    return _yael.abinheap_init(bh, maxk, labelsize)

def abinheap_delete(bh: "abinheap_s") -> "void":
    return _yael.abinheap_delete(bh)

def abinheap_reset(bh: "abinheap_s") -> "void":
    return _yael.abinheap_reset(bh)

def abinheap_add(bh: "abinheap_s", label: "void *", val: "float") -> "void":
    return _yael.abinheap_add(bh, label, val)

def abinheap_pop(bh: "abinheap_s") -> "void":
    return _yael.abinheap_pop(bh)

def abinheap_sort(bh: "abinheap_s", labels: "void *", v: "float *") -> "void":
    return _yael.abinheap_sort(bh, labels, v)

def abinheap_get_label(bh: "abinheap_s", i: "int") -> "void *":
    return _yael.abinheap_get_label(bh, i)

def gaussrand() -> "double":
    return _yael.gaussrand()

def fvec_new(n: "long") -> "float *":
    return _yael.fvec_new(n)

def ivec_new(n: "long") -> "int *":
    return _yael.ivec_new(n)

def bvec_new(n: "long") -> "unsigned char *":
    return _yael.bvec_new(n)

def lvec_new(n: "long") -> "long long *":
    return _yael.lvec_new(n)

def dvec_new(n: "long") -> "double *":
    return _yael.dvec_new(n)

def fvec_new_0(n: "long") -> "float *":
    return _yael.fvec_new_0(n)

def dvec_new_0(n: "long") -> "double *":
    return _yael.dvec_new_0(n)

def ivec_new_0(n: "long") -> "int *":
    return _yael.ivec_new_0(n)

def bvec_new_0(n: "long") -> "unsigned char *":
    return _yael.bvec_new_0(n)

def lvec_new_0(n: "long") -> "long long *":
    return _yael.lvec_new_0(n)

def fvec_new_nan(n: "long") -> "float *":
    return _yael.fvec_new_nan(n)

def fvec_new_set(n: "long", val: "float") -> "float *":
    return _yael.fvec_new_set(n, val)

def ivec_new_set(n: "long", val: "int") -> "int *":
    return _yael.ivec_new_set(n, val)

def fvec_new_rand(n: "long") -> "float *":
    return _yael.fvec_new_rand(n)

def fvec_new_randn(n: "long") -> "float *":
    return _yael.fvec_new_randn(n)

def fvec_randn_r(v: "float *", n: "long", seed: "unsigned int") -> "void":
    return _yael.fvec_randn_r(v, n, seed)

def fvec_new_rand_r(n: "long", seed: "unsigned int") -> "float *":
    return _yael.fvec_new_rand_r(n, seed)

def fvec_new_randn_r(n: "long", seed: "unsigned int") -> "float *":
    return _yael.fvec_new_randn_r(n, seed)

def ivec_new_range(a: "long", b: "long") -> "int *":
    return _yael.ivec_new_range(a, b)

def ivec_new_cpy(v: "int const *", n: "long") -> "int *":
    return _yael.ivec_new_cpy(v, n)

def fvec_new_cpy(v: "float const *", n: "long") -> "float *":
    return _yael.fvec_new_cpy(v, n)

def ivec_new_random_perm(n: "int") -> "int *":
    return _yael.ivec_new_random_perm(n)

def ivec_new_random_idx(n: "int", k: "int") -> "int *":
    return _yael.ivec_new_random_idx(n, k)

def ivec_new_random_perm_r(n: "int", seed: "unsigned int") -> "int *":
    return _yael.ivec_new_random_perm_r(n, seed)

def ivec_new_random_idx_r(n: "int", k: "int", seed: "unsigned int") -> "int *":
    return _yael.ivec_new_random_idx_r(n, k, seed)

def fvec_resize(v: "float *", n: "long") -> "float *":
    return _yael.fvec_resize(v, n)

def ivec_resize(v: "int *", n: "long") -> "int *":
    return _yael.ivec_resize(v, n)

def ivec_new_histogram(k: "int", v: "int const *", n: "long") -> "int *":
    return _yael.ivec_new_histogram(k, v, n)

def ivec_new_histogram_clip(k: "int", v: "int *", n: "long") -> "int *":
    return _yael.ivec_new_histogram_clip(k, v, n)

def fvec_new_histogram_clip(vmin: "float", vmax: "float", k: "int", v: "float *", n: "long") -> "int *":
    return _yael.fvec_new_histogram_clip(vmin, vmax, k, v, n)

def ivec_hash(v: "int const *", n: "long") -> "int":
    return _yael.ivec_hash(v, n)

def ivec_replace(v: "int *", n: "long", val: "int", replace_val: "int") -> "void":
    return _yael.ivec_replace(v, n, val, replace_val)

def ivec_count_occurrences(v: "int const *", n: "long", val: "int") -> "long":
    return _yael.ivec_count_occurrences(v, n, val)

def fvec_count_occurrences(v: "float const *", n: "long", val: "float") -> "long":
    return _yael.fvec_count_occurrences(v, n, val)

def fvec_count_lt(v: "float const *", n: "long", val: "float") -> "long":
    return _yael.fvec_count_lt(v, n, val)

def ivec_count_lt(v: "int const *", n: "long", val: "int") -> "long":
    return _yael.ivec_count_lt(v, n, val)

def fvec_count_gt(v: "float const *", n: "long", val: "float") -> "long":
    return _yael.fvec_count_gt(v, n, val)

def ivec_count_gt(v: "int const *", n: "long", val: "int") -> "long":
    return _yael.ivec_count_gt(v, n, val)

def fvec_count_inrange(v: "float const *", n: "long", vmin: "float", vmax: "float") -> "long":
    return _yael.fvec_count_inrange(v, n, vmin, vmax)

def ivec_count_inrange(v: "int const *", n: "long", vmin: "int", vmax: "int") -> "long":
    return _yael.ivec_count_inrange(v, n, vmin, vmax)

def fvec_count_nan(v: "float const *", n: "long") -> "long":
    return _yael.fvec_count_nan(v, n)

def fvec_count_nonfinite(v: "float const *", n: "long") -> "long":
    return _yael.fvec_count_nonfinite(v, n)

def fvec_count_0(val: "float const *", n: "long") -> "long":
    return _yael.fvec_count_0(val, n)

def fvecs_fsize(fname: "char const *") -> "int *":
    return _yael.fvecs_fsize(fname)

def ivecs_fsize(fname: "char const *") -> "int *":
    return _yael.ivecs_fsize(fname)

def bvecs_fsize(fname: "char const *") -> "int *":
    return _yael.bvecs_fsize(fname)

def lvecs_fsize(fname: "char const *") -> "int *":
    return _yael.lvecs_fsize(fname)

def ivec_fwrite(f: "FILE *", v: "int const *", d: "int") -> "int":
    return _yael.ivec_fwrite(f, v, d)

def fvec_fwrite(f: "FILE *", v: "float const *", d: "int") -> "int":
    return _yael.fvec_fwrite(f, v, d)

def ivec_fwrite_raw(f: "FILE *", v: "int const *", d: "long") -> "int":
    return _yael.ivec_fwrite_raw(f, v, d)

def fvec_fwrite_raw(f: "FILE *", v: "float const *", d: "long") -> "int":
    return _yael.fvec_fwrite_raw(f, v, d)

def bvec_fwrite_raw(f: "FILE *", v: "unsigned char const *", d: "long") -> "int":
    return _yael.bvec_fwrite_raw(f, v, d)

def ivec_write_raw(fname: "char const *", v: "int const *", d: "long") -> "int":
    return _yael.ivec_write_raw(fname, v, d)

def fvec_write_raw(fname: "char const *", v: "float const *", d: "long") -> "int":
    return _yael.fvec_write_raw(fname, v, d)

def bvec_write_raw(fname: "char const *", v: "unsigned char const *", d: "long") -> "int":
    return _yael.bvec_write_raw(fname, v, d)

def ivecs_fwrite(f: "FILE *", d: "int", n: "int", v: "int const *") -> "int":
    return _yael.ivecs_fwrite(f, d, n, v)

def fvecs_fwrite(fo: "FILE *", d: "int", n: "int", vf: "float const *") -> "int":
    return _yael.fvecs_fwrite(fo, d, n, vf)

def ivecs_write(fname: "char const *", d: "int", n: "int", v: "int const *") -> "int":
    return _yael.ivecs_write(fname, d, n, v)

def ivecs_write_txt(fname: "char const *", d: "int", n: "int", v: "int const *") -> "int":
    return _yael.ivecs_write_txt(fname, d, n, v)

def fvecs_write(fname: "char const *", d: "int", n: "int", vf: "float const *") -> "int":
    return _yael.fvecs_write(fname, d, n, vf)

def fvecs_write_txt(fname: "char const *", d: "int", n: "int", vf: "float const *") -> "int":
    return _yael.fvecs_write_txt(fname, d, n, vf)

def bvecs_write(fname: "char const *", d: "int", n: "int", v: "unsigned char const *") -> "int":
    return _yael.bvecs_write(fname, d, n, v)

def fvecs_new_read(fname: "char const *") -> "float **":
    return _yael.fvecs_new_read(fname)

def fvecs_new_fread_max(f: "FILE *", nmax: "long") -> "float **":
    return _yael.fvecs_new_fread_max(f, nmax)

def fvecs_new_mmap(fname: "char const *") -> "float **":
    return _yael.fvecs_new_mmap(fname)

def ivecs_new_mmap(fname: "char const *") -> "int **":
    return _yael.ivecs_new_mmap(fname)

def bvecs_new_read(fname: "char const *", v_out: "unsigned char **") -> "int *":
    return _yael.bvecs_new_read(fname, v_out)

def lvecs_new_read(fname: "char const *", v_out: "long long **") -> "int *":
    return _yael.lvecs_new_read(fname, v_out)

def b2fvecs_new_read(fname: "char const *", v_out: "float **") -> "int *":
    return _yael.b2fvecs_new_read(fname, v_out)

def fvecs_new_read_sparse(fname: "char const *", d: "int") -> "float **":
    return _yael.fvecs_new_read_sparse(fname, d)

def bvecs_new_from_siftgeo(fname: "char const *", d_v_out: "int *", v_out: "unsigned char **", d_meta_out: "int *", meta_out: "float **") -> "int":
    return _yael.bvecs_new_from_siftgeo(fname, d_v_out, v_out, d_meta_out, meta_out)

def fvecs_read(fname: "char const *", d: "int", n: "int", v: "float *") -> "int":
    return _yael.fvecs_read(fname, d, n, v)

def b2fvecs_read(fname: "char const *", d: "int", n: "int", v: "float *") -> "int":
    return _yael.b2fvecs_read(fname, d, n, v)

def fvecs_read_txt(fname: "char const *", d: "int", n: "int", v: "float *") -> "int":
    return _yael.fvecs_read_txt(fname, d, n, v)

def fvec_read(fname: "char const *", d: "int", a: "float *", o_f: "int") -> "int":
    return _yael.fvec_read(fname, d, a, o_f)

def fvec_fread(f: "FILE *", v: "float *", d_alloc: "int") -> "int":
    return _yael.fvec_fread(f, v, d_alloc)

def fvec_fread_raw(f: "FILE *", v: "float *", n: "long") -> "int":
    return _yael.fvec_fread_raw(f, v, n)

def ivec_fread_raw(f: "FILE *", v: "int *", n: "long") -> "int":
    return _yael.ivec_fread_raw(f, v, n)

def bvec_fread_raw(f: "FILE *", v: "unsigned char *", n: "long") -> "int":
    return _yael.bvec_fread_raw(f, v, n)

def fvec_new_fread_raw(f: "FILE *", n: "long") -> "float *":
    return _yael.fvec_new_fread_raw(f, n)

def ivec_new_fread_raw(f: "FILE *", d: "long") -> "int *":
    return _yael.ivec_new_fread_raw(f, d)

def bvec_new_fread_raw(f: "FILE *", n: "long") -> "unsigned char *":
    return _yael.bvec_new_fread_raw(f, n)

def fvec_new_read_raw(fname: "char const *", d: "long") -> "float *":
    return _yael.fvec_new_read_raw(fname, d)

def ivec_new_read_raw(fname: "char const *", d: "long") -> "int *":
    return _yael.ivec_new_read_raw(fname, d)

def bvec_new_read_raw(fname: "char const *", d: "long") -> "unsigned char *":
    return _yael.bvec_new_read_raw(fname, d)

def fvecs_fread(f: "FILE *", v: "float *", n: "long", d_alloc: "int") -> "long":
    return _yael.fvecs_fread(f, v, n, d_alloc)

def ivecs_fread(f: "FILE *", v: "int *", n: "long", d_alloc: "int") -> "long":
    return _yael.ivecs_fread(f, v, n, d_alloc)

def bvecs_fread(f: "FILE *", v: "unsigned char *", n: "long", d_alloc: "int") -> "long":
    return _yael.bvecs_fread(f, v, n, d_alloc)

def lvecs_fread(f: "FILE *", v: "long long *", n: "long", d_alloc: "int") -> "long":
    return _yael.lvecs_fread(f, v, n, d_alloc)

def b2fvecs_fread(f: "FILE *", v: "float *", n: "long") -> "long":
    return _yael.b2fvecs_fread(f, v, n)

def ivec_new_read(fname: "char const *") -> "int *":
    return _yael.ivec_new_read(fname)

def ivec_fread(f: "FILE *", v: "int *", d_alloc: "int") -> "int":
    return _yael.ivec_fread(f, v, d_alloc)

def bvec_fread(f: "FILE *", v: "unsigned char *", d_alloc: "int") -> "int":
    return _yael.bvec_fread(f, v, d_alloc)

def b2fvec_fread(f: "FILE *", v: "float *") -> "int":
    return _yael.b2fvec_fread(f, v)

def lvec_fread(f: "FILE *", v: "long long *", d_alloc: "int") -> "int":
    return _yael.lvec_fread(f, v, d_alloc)

def ivecs_new_read(fname: "char const *") -> "int **":
    return _yael.ivecs_new_read(fname)

def ivecs_new_fread_max(f: "FILE *", nmax: "long") -> "int **":
    return _yael.ivecs_new_fread_max(f, nmax)

def fvec_print(v: "float const *", n: "int") -> "void":
    return _yael.fvec_print(v, n)

def fvec_fprintf(f: "FILE *", v: "float const *", n: "int", fmt: "char const *") -> "void":
    return _yael.fvec_fprintf(f, v, n, fmt)

def ivec_print(v: "int const *", n: "int") -> "void":
    return _yael.ivec_print(v, n)

def ivec_fprintf(f: "FILE *", v: "int const *", n: "int", fmt: "char const *") -> "void":
    return _yael.ivec_fprintf(f, v, n, fmt)

def ivec_index(v: "int const *", n: "long", val: "int") -> "long":
    return _yael.ivec_index(v, n, val)

def ivec2fvec(v: "int const *", n: "long") -> "float *":
    return _yael.ivec2fvec(v, n)

def bvec2fvec(v: "unsigned char const *", n: "long") -> "float *":
    return _yael.bvec2fvec(v, n)

def bvectofvec(v: "unsigned char const *", vb: "float *", n: "long") -> "void":
    return _yael.bvectofvec(v, vb, n)

def fvectodvec(a: "float const *", b: "double *", n: "long") -> "void":
    return _yael.fvectodvec(a, b, n)

def fvec_0(v: "float *", n: "long") -> "void":
    return _yael.fvec_0(v, n)

def ivec_0(v: "int *", n: "long") -> "void":
    return _yael.ivec_0(v, n)

def fvec_nan(v: "float *", n: "long") -> "void":
    return _yael.fvec_nan(v, n)

def fvec_rand(v: "float *", n: "long") -> "void":
    return _yael.fvec_rand(v, n)

def fvec_randn(v: "float *", n: "long") -> "void":
    return _yael.fvec_randn(v, n)

def fvec_all_0(v: "float const *", n: "long") -> "int":
    return _yael.fvec_all_0(v, n)

def ivec_all_0(v: "int const *", n: "long") -> "int":
    return _yael.ivec_all_0(v, n)

def fvec_all_ge0(v: "float const *", n: "long") -> "int":
    return _yael.fvec_all_ge0(v, n)

def ivec_all_ge0(v: "int const *", n: "long") -> "int":
    return _yael.ivec_all_ge0(v, n)

def fvec_all_finite(v: "float const *", n: "long") -> "int":
    return _yael.fvec_all_finite(v, n)

def fvec_set(v: "float *", n: "long", val: "float") -> "void":
    return _yael.fvec_set(v, n, val)

def ivec_set(v: "int *", n: "long", val: "int") -> "void":
    return _yael.ivec_set(v, n, val)

def ivec_cpy(vdest: "int *", vsource: "int const *", n: "long") -> "void":
    return _yael.ivec_cpy(vdest, vsource, n)

def fvec_cpy(vdest: "float *", vsource: "float const *", n: "long") -> "void":
    return _yael.fvec_cpy(vdest, vsource, n)

def bvec_cpy(vdest: "unsigned char *", vsource: "unsigned char const *", n: "long") -> "void":
    return _yael.bvec_cpy(vdest, vsource, n)

def fvec_incr(v: "float *", n: "long", scal: "double") -> "void":
    return _yael.fvec_incr(v, n, scal)

def fvec_decr(v: "float *", n: "long", scal: "double") -> "void":
    return _yael.fvec_decr(v, n, scal)

def ivec_incr(v: "int *", n: "long", scal: "int") -> "void":
    return _yael.ivec_incr(v, n, scal)

def ivec_decr(v: "int *", n: "long", scal: "int") -> "void":
    return _yael.ivec_decr(v, n, scal)

def fvec_mul_by(v: "float *", n: "long", scal: "double") -> "void":
    return _yael.fvec_mul_by(v, n, scal)

def fvec_div_by(v: "float *", n: "long", scal: "double") -> "void":
    return _yael.fvec_div_by(v, n, scal)

def fvec_rdiv_by(v: "float *", n: "long", scal: "double") -> "void":
    return _yael.fvec_rdiv_by(v, n, scal)

def fvec_add(v1: "float *", v2: "float const *", n: "long") -> "void":
    return _yael.fvec_add(v1, v2, n)

def fvec_sub(v1: "float *", v2: "float const *", n: "long") -> "void":
    return _yael.fvec_sub(v1, v2, n)

def fvec_rev_sub(v1: "float *", v2: "float const *", n: "long") -> "void":
    return _yael.fvec_rev_sub(v1, v2, n)

def fvec_add_mul(v1: "float *", v2: "float const *", n: "long", scal: "double") -> "void":
    return _yael.fvec_add_mul(v1, v2, n, scal)

def fvec_mul(v1: "float *", v2: "float const *", n: "long") -> "void":
    return _yael.fvec_mul(v1, v2, n)

def fvec_div(v1: "float *", v2: "float const *", n: "long") -> "void":
    return _yael.fvec_div(v1, v2, n)

def fvec_normalize(v: "float *", n: "long", norm: "double") -> "double":
    return _yael.fvec_normalize(v, n, norm)

def fvecs_normalize(v: "float *", n: "long", d: "long", norm: "double") -> "int":
    return _yael.fvecs_normalize(v, n, d, norm)

def fvec_round(v: "float *", n: "long") -> "void":
    return _yael.fvec_round(v, n)

def fvec_sqrt(v: "float *", n: "long") -> "void":
    return _yael.fvec_sqrt(v, n)

def fvec_sqr(v: "float *", n: "long") -> "void":
    return _yael.fvec_sqr(v, n)

def fvec_exp(v: "float *", n: "long") -> "void":
    return _yael.fvec_exp(v, n)

def fvec_log(v: "float *", n: "long") -> "void":
    return _yael.fvec_log(v, n)

def fvec_neg(v: "float *", n: "long") -> "void":
    return _yael.fvec_neg(v, n)

def fvec_ssqrt(v: "float *", n: "long") -> "void":
    return _yael.fvec_ssqrt(v, n)

def fvec_spow(v: "float *", n: "long", scal: "double") -> "void":
    return _yael.fvec_spow(v, n, scal)

def fvec_normalize_2stage(v: "float *", n: "long", scal: "double") -> "void":
    return _yael.fvec_normalize_2stage(v, n, scal)

def ivec_add(v1: "int *", v2: "int const *", n: "long") -> "void":
    return _yael.ivec_add(v1, v2, n)

def ivec_sub(v1: "int *", v2: "int const *", n: "long") -> "void":
    return _yael.ivec_sub(v1, v2, n)

def ivec_mul_by(v1: "int *", n: "long", scal: "int") -> "void":
    return _yael.ivec_mul_by(v1, n, scal)

def ivec_mod_by(v1: "int *", n: "long", scal: "int") -> "void":
    return _yael.ivec_mod_by(v1, n, scal)

def ivec_add_scalar(v: "int *", n: "long", scal: "int") -> "void":
    return _yael.ivec_add_scalar(v, n, scal)

def fvec_add_scalar(v: "float *", n: "long", scal: "float") -> "void":
    return _yael.fvec_add_scalar(v, n, scal)

def fvec_purge_nans(v: "float *", n: "long", replace_value: "float") -> "long":
    return _yael.fvec_purge_nans(v, n, replace_value)

def fvec_purge_nonfinite(v: "float *", n: "long", replace_value: "float") -> "int":
    return _yael.fvec_purge_nonfinite(v, n, replace_value)

def fvec_shrink_nonfinite(v: "float *", n: "long") -> "long":
    return _yael.fvec_shrink_nonfinite(v, n)

def fvec_index_nonfinite(v: "float *", n: "long") -> "long":
    return _yael.fvec_index_nonfinite(v, n)

def fvec_revert(v: "float *", n: "long") -> "void":
    return _yael.fvec_revert(v, n)

def fvec_swap(v1: "float *", v2: "float *", n: "long") -> "void":
    return _yael.fvec_swap(v1, v2, n)

def fvec_sum(v: "float const *", n: "long") -> "double":
    return _yael.fvec_sum(v, n)

def ivec_sum(v: "int const *", n: "long") -> "long long":
    return _yael.ivec_sum(v, n)

def fvec_cumsum(v: "float *", n: "long") -> "void":
    return _yael.fvec_cumsum(v, n)

def ivec_cumsum(v: "int *", n: "long") -> "void":
    return _yael.ivec_cumsum(v, n)

def fvec_cumdiff(v: "float *", n: "long") -> "void":
    return _yael.fvec_cumdiff(v, n)

def ivec_cumdiff(v: "int *", n: "long") -> "void":
    return _yael.ivec_cumdiff(v, n)

def fvec_product(v: "float const *", n: "long") -> "double":
    return _yael.fvec_product(v, n)

def ivec_product(v: "int const *", n: "long") -> "long long":
    return _yael.ivec_product(v, n)

def fvec_sum_sqr(v: "float const *", n: "long") -> "double":
    return _yael.fvec_sum_sqr(v, n)

def ivec_sum_sqr(v: "int const *", n: "long") -> "long long":
    return _yael.ivec_sum_sqr(v, n)

def fvec_mean(v: "float const *", n: "long") -> "double":
    return _yael.fvec_mean(v, n)

def ivec_mean(v: "int const *", n: "long") -> "long long":
    return _yael.ivec_mean(v, n)

def fvec_norm(v: "float const *", n: "long", norm: "double") -> "double":
    return _yael.fvec_norm(v, n, norm)

def fvec_norm2sqr(v: "float const *", n: "long") -> "double":
    return _yael.fvec_norm2sqr(v, n)

def fvec_nz(v: "float const *", n: "long") -> "long":
    return _yael.fvec_nz(v, n)

def ivec_nz(v: "int const *", n: "long") -> "long":
    return _yael.ivec_nz(v, n)

def fvec_find(v: "float const *", n: "int", nzpos_out: "int **") -> "int":
    return _yael.fvec_find(v, n, nzpos_out)

def ivec_find(v: "int const *", n: "int", nzpos_out: "int **") -> "int":
    return _yael.ivec_find(v, n, nzpos_out)

def ivec_shuffle(v: "int *", n: "long") -> "void":
    return _yael.ivec_shuffle(v, n)

def fvec_entropy(pmf: "float const *", n: "int") -> "double":
    return _yael.fvec_entropy(pmf, n)

def binary_entropy(p: "double") -> "double":
    return _yael.binary_entropy(p)

def ivec_unbalanced_factor(hist: "int const *", n: "long") -> "double":
    return _yael.ivec_unbalanced_factor(hist, n)

def ivec_distance_hamming(v1: "int const *", v2: "int const *", n: "long") -> "long":
    return _yael.ivec_distance_hamming(v1, v2, n)

def fvec_distance_L2(v1: "float const *", v2: "float const *", n: "long") -> "double":
    return _yael.fvec_distance_L2(v1, v2, n)

def fvec_distance_L1(v1: "float const *", v2: "float const *", n: "long") -> "double":
    return _yael.fvec_distance_L1(v1, v2, n)

def fvec_distance_L2sqr(v1: "float const *", v2: "float const *", n: "long") -> "double":
    return _yael.fvec_distance_L2sqr(v1, v2, n)

def fvec_inner_product(v1: "float const *", v2: "float const *", n: "long") -> "double":
    return _yael.fvec_inner_product(v1, v2, n)

def fvec_to_spfvec(v: "float *", n: "int") -> "float **":
    return _yael.fvec_to_spfvec(v, n)

def ivec_to_spivec(v: "int *", n: "int", idx_out: "int **", v_out: "int **") -> "int":
    return _yael.ivec_to_spivec(v, n, idx_out, v_out)

def spfvec_to_fvec(idx: "int *", v: "float *", nz: "int", n: "int") -> "float *":
    return _yael.spfvec_to_fvec(idx, v, nz, n)

def spivec_to_ivec(idx: "int *", v: "int *", nz: "int", n: "int") -> "int *":
    return _yael.spivec_to_ivec(idx, v, nz, n)

def spfvec_inner_product(idx1: "int *", val1: "float *", nz1: "int", idx2: "int *", val2: "float *", nz2: "int") -> "float":
    return _yael.spfvec_inner_product(idx1, val1, nz1, idx2, val2, nz2)

def ivec_accumulate_slices(v: "int const *", sl: "int *", n: "int") -> "void":
    return _yael.ivec_accumulate_slices(v, sl, n)

def fvec_map(src: "float const *", map: "int const *", n: "int", dest: "float *") -> "void":
    return _yael.fvec_map(src, map, n, dest)

def ivec_map(src: "int const *", map: "int const *", n: "int", dest: "int *") -> "void":
    return _yael.ivec_map(src, map, n, dest)

def fvec_imap(src: "float const *", imap: "int const *", n: "int", dest: "float *") -> "void":
    return _yael.fvec_imap(src, imap, n, dest)

def fvec_splat_add(a: "float const *", n: "int", assign: "int const *", accu: "float *") -> "void":
    return _yael.fvec_splat_add(a, n, assign, accu)

def fvec_isplat_add(a: "float const *", n: "int", assign: "int const *", accu: "float *") -> "void":
    return _yael.fvec_isplat_add(a, n, assign, accu)

def ivec_repeat_with_inc(a: "int const *", n: "int", nrepeat: "int", inc: "int") -> "int *":
    return _yael.ivec_repeat_with_inc(a, n, nrepeat, inc)

def fvec_cpy_subvectors(v: "float const *", idx: "int *", d: "int", nout: "int", vout: "float *") -> "void":
    return _yael.fvec_cpy_subvectors(v, idx, d, nout, vout)

def b2fvec_cpy_subvectors(v: "unsigned char const *", idx: "int *", d: "int", nout: "int", vout: "float *") -> "void":
    return _yael.b2fvec_cpy_subvectors(v, idx, d, nout, vout)

def ivec_to_fvec(v: "int const *", f: "float *", n: "long") -> "void":
    return _yael.ivec_to_fvec(v, f, n)

def fmat_new(nrow: "int", ncol: "int") -> "float *":
    return _yael.fmat_new(nrow, ncol)

def fmat_new_0(nrow: "int", ncol: "int") -> "float *":
    return _yael.fmat_new_0(nrow, ncol)

def fmat_mul_full(left: "float const *", right: "float const *", m: "int", n: "int", k: "int", transp: "char const *", result: "float *") -> "void":
    return _yael.fmat_mul_full(left, right, m, n, k, transp, result)

def fmat_mul_full_nonpacked(left: "float const *", right: "float const *", m: "int", n: "int", k: "int", transp: "char const *", ld_left: "int", ld_right: "int", result: "float *", ld_result: "int") -> "void":
    return _yael.fmat_mul_full_nonpacked(left, right, m, n, k, transp, ld_left, ld_right, result, ld_result)

def fmat_new_mul_full(left: "float const *", right: "float const *", m: "int", n: "int", k: "int", transp: "char const *") -> "float *":
    return _yael.fmat_new_mul_full(left, right, m, n, k, transp)

def fmat_mul(left: "float const *", right: "float const *", m: "int", n: "int", k: "int", mout: "float *") -> "void":
    return _yael.fmat_mul(left, right, m, n, k, mout)

def fmat_mul_tl(left: "float const *", right: "float const *", m: "int", n: "int", k: "int", mout: "float *") -> "void":
    return _yael.fmat_mul_tl(left, right, m, n, k, mout)

def fmat_mul_tr(left: "float const *", right: "float const *", m: "int", n: "int", k: "int", mout: "float *") -> "void":
    return _yael.fmat_mul_tr(left, right, m, n, k, mout)

def fmat_mul_tlr(left: "float const *", right: "float const *", m: "int", n: "int", k: "int", mout: "float *") -> "void":
    return _yael.fmat_mul_tlr(left, right, m, n, k, mout)

def fmat_new_mul(left: "float const *", right: "float const *", m: "int", n: "int", k: "int") -> "float *":
    return _yael.fmat_new_mul(left, right, m, n, k)

def fmat_new_mul_tl(left: "float const *", right: "float const *", m: "int", n: "int", k: "int") -> "float *":
    return _yael.fmat_new_mul_tl(left, right, m, n, k)

def fmat_new_mul_tr(left: "float const *", right: "float const *", m: "int", n: "int", k: "int") -> "float *":
    return _yael.fmat_new_mul_tr(left, right, m, n, k)

def fmat_new_mul_tlr(left: "float const *", right: "float const *", m: "int", n: "int", k: "int") -> "float *":
    return _yael.fmat_new_mul_tlr(left, right, m, n, k)

def fmat_solve_ls_t(m: "int", n: "int", a: "float const *", b: "float const *", x: "float *") -> "int":
    return _yael.fmat_solve_ls_t(m, n, a, b, x)

def fmat_print(a: "float const *", nrow: "int", ncol: "int") -> "void":
    return _yael.fmat_print(a, nrow, ncol)

def fmat_print_tranposed(a: "float const *", nrow: "int", ncol: "int") -> "void":
    return _yael.fmat_print_tranposed(a, nrow, ncol)

def fmat_get_submatrix(a: "float const *", nrow: "int", nrow_out: "int", ncol: "int") -> "float *":
    return _yael.fmat_get_submatrix(a, nrow, nrow_out, ncol)

def imat_get_submatrix(a: "int const *", nrow: "int", nrow_out: "int", ncol: "int") -> "int *":
    return _yael.imat_get_submatrix(a, nrow, nrow_out, ncol)

def fmat_new_get_columns(a: "float const *", nrow: "int", ncolout: "int", cols: "int const *") -> "float *":
    return _yael.fmat_new_get_columns(a, nrow, ncolout, cols)

def fmat_get_columns(a: "float const *", d: "int", ncolout: "int", cols: "int const *", out: "float *") -> "void":
    return _yael.fmat_get_columns(a, d, ncolout, cols, out)

def fmat_get_rows_cols(a: "float const *", d: "int", n_row: "int", rows: "int const *", n_col: "int", cols: "int const *", out: "float *") -> "void":
    return _yael.fmat_get_rows_cols(a, d, n_row, rows, n_col, cols, out)

def fmat_shuffle_columns(a: "float *", nrow: "int", ncol: "int") -> "void":
    return _yael.fmat_shuffle_columns(a, nrow, ncol)

def fmat_new_get_row(a: "float const *", nrow: "int", ncol: "int", row: "int") -> "float *":
    return _yael.fmat_new_get_row(a, nrow, ncol, row)

def fmat_new_get_rows(a: "float const *", d: "int", n: "int", nrowout: "int", rows: "int const *") -> "float *":
    return _yael.fmat_new_get_rows(a, d, n, nrowout, rows)

def fmat_sum_columns(a: "float const *", nrow: "int", ncol: "int", sums: "float *") -> "void":
    return _yael.fmat_sum_columns(a, nrow, ncol, sums)

def fmat_new_sum_columns(a: "float const *", nrow: "int", ncol: "int") -> "float *":
    return _yael.fmat_new_sum_columns(a, nrow, ncol)

def fmat_sum_rows(a: "float const *", nrow: "int", ncol: "int", sums: "float *") -> "void":
    return _yael.fmat_sum_rows(a, nrow, ncol, sums)

def fmat_new_sum_rows(a: "float const *", nrow: "int", ncol: "int") -> "float *":
    return _yael.fmat_new_sum_rows(a, nrow, ncol)

def fmat_new_vstack(a: "float const *", da: "int", b: "float const *", db: "int", n: "int") -> "float *":
    return _yael.fmat_new_vstack(a, da, b, db, n)

def fmat_new_transp(a: "float const *", ncol: "int", nrow: "int") -> "float *":
    return _yael.fmat_new_transp(a, ncol, nrow)

def fmat_splat_separable(a: "float const *", nrow: "int", ncol: "int", row_assign: "int const *", col_assign: "int const *", k: "int", accu: "float *") -> "void":
    return _yael.fmat_splat_separable(a, nrow, ncol, row_assign, col_assign, k, accu)

def fmat_splat_separable_1D(a: "float const *", nrow: "int", ncol: "int", assign: "int const *", accu: "float *") -> "void":
    return _yael.fmat_splat_separable_1D(a, nrow, ncol, assign, accu)

def imat_joint_histogram(n: "int", k: "int", row_assign: "int *", col_assign: "int *") -> "int *":
    return _yael.imat_joint_histogram(n, k, row_assign, col_assign)

def fmat_remove_0_columns(a: "float *", d: "int", n: "int") -> "int":
    return _yael.fmat_remove_0_columns(a, d, n)

def fmat_normalize_columns_l2sqr_pow(a: "float *", d: "int", n: "int", pw: "float") -> "void":
    return _yael.fmat_normalize_columns_l2sqr_pow(a, d, n, pw)

def fmat_normalize_columns_l2sqr_pow_robust(a: "float *", d: "int", n: "int", pw: "float", eps: "float") -> "void":
    return _yael.fmat_normalize_columns_l2sqr_pow_robust(a, d, n, pw, eps)

def fmat_new_rand_gauss(nrow: "int", ncol: "int") -> "float *":
    return _yael.fmat_new_rand_gauss(nrow, ncol)

def random_orthogonal_basis(d: "int") -> "float *":
    return _yael.random_orthogonal_basis(d)

def hadamard(d: "int") -> "float *":
    return _yael.hadamard(d)

def fmat_center_columns(d: "int", n: "int", v: "float *") -> "float *":
    return _yael.fmat_center_columns(d, n, v)

def fmat_subtract_from_columns(d: "int", n: "int", m: "float *", avg: "float const *") -> "void":
    return _yael.fmat_subtract_from_columns(d, n, m, avg)

def fmat_add_to_columns(d: "int", n: "int", m: "float *", avg: "float const *") -> "void":
    return _yael.fmat_add_to_columns(d, n, m, avg)

def fmat_rev_subtract_from_columns(d: "int", n: "int", m: "float *", avg: "float const *") -> "void":
    return _yael.fmat_rev_subtract_from_columns(d, n, m, avg)

def fmat_new_covariance(d: "int", n: "int", v: "float const *", avg: "float *", assume_centered: "int") -> "float *":
    return _yael.fmat_new_covariance(d, n, v, avg, assume_centered)

def fmat_new_pca(d: "int", n: "int", v: "float const *", singvals: "float *") -> "float *":
    return _yael.fmat_new_pca(d, n, v, singvals)

def fmat_new_pca_part(d: "int", n: "int", nev: "int", v: "float const *", singvals: "float *") -> "float *":
    return _yael.fmat_new_pca_part(d, n, nev, v, singvals)

def fmat_svd_partial(d: "int", n: "int", ns: "int", a: "float const *", singvals: "float *", u: "float *", v: "float *") -> "int":
    return _yael.fmat_svd_partial(d, n, ns, a, singvals, u, v)

def fmat_svd_partial_full(n: "int", m: "int", nev: "int", a: "float const *", a_transposed: "int", s: "float *", vout: "float *", uout: "float *", nt: "int") -> "int":
    return _yael.fmat_svd_partial_full(n, m, nev, a, a_transposed, s, vout, uout, nt)

def fmat_new_pca_from_covariance(d: "int", cov: "float const *", singvals: "float *") -> "float *":
    return _yael.fmat_new_pca_from_covariance(d, cov, singvals)

def fmat_pca_from_covariance(d: "int", cov: "float const *", singvals: "float *", pcamat: "float *") -> "void":
    return _yael.fmat_pca_from_covariance(d, cov, singvals, pcamat)
class pca_online_s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_yael.pca_online_s_n_get, _yael.pca_online_s_n_set)
    d = property(_yael.pca_online_s_d_get, _yael.pca_online_s_d_set)
    mu = property(_yael.pca_online_s_mu_get, _yael.pca_online_s_mu_set)
    cov = property(_yael.pca_online_s_cov_get, _yael.pca_online_s_cov_set)
    eigvec = property(_yael.pca_online_s_eigvec_get, _yael.pca_online_s_eigvec_set)
    eigval = property(_yael.pca_online_s_eigval_get, _yael.pca_online_s_eigval_set)

    def __init__(self):
        _yael.pca_online_s_swiginit(self, _yael.new_pca_online_s())
    __swig_destroy__ = _yael.delete_pca_online_s

# Register pca_online_s in _yael:
_yael.pca_online_s_swigregister(pca_online_s)


def pca_online_new(d: "int") -> "pca_online_t *":
    return _yael.pca_online_new(d)

def pca_online_delete(pca: "pca_online_s") -> "void":
    return _yael.pca_online_delete(pca)

def pca_online_accu(pca: "pca_online_s", v: "float const *", n: "long") -> "void":
    return _yael.pca_online_accu(pca, v, n)

def pca_online_cov(pca: "pca_online_s") -> "void":
    return _yael.pca_online_cov(pca)

def pca_online_complete(pca: "pca_online_s") -> "void":
    return _yael.pca_online_complete(pca)

def pca_online_complete_part(pca: "pca_online_s", nev: "int") -> "void":
    return _yael.pca_online_complete_part(pca, nev)

def pca_online_project(pca: "pca_online_s", v: "float const *", vo: "float *", d: "int", n: "long", dout: "int") -> "void":
    return _yael.pca_online_project(pca, v, vo, d, n, dout)

def eigs_sym(d: "int", m: "float const *", eigval: "float *", eigvec: "float *") -> "int":
    return _yael.eigs_sym(d, m, eigval, eigvec)

def geigs_sym(d: "int", a: "float const *", b: "float const *", eigval: "float *", eigvec: "float *") -> "int":
    return _yael.geigs_sym(d, a, b, eigval, eigvec)

def eigs_reorder(d: "int", eigval: "float *", eigvec: "float *", criterion: "int") -> "void":
    return _yael.eigs_reorder(d, eigval, eigvec, criterion)

def eigs_sym_part(d: "int", m: "float const *", nev: "int", eigval: "float *", eigvec: "float *") -> "int":
    return _yael.eigs_sym_part(d, m, nev, eigval, eigvec)

def arpack_eigs_begin(n: "int", nev: "int") -> "arpack_eigs_t *":
    return _yael.arpack_eigs_begin(n, nev)

def arpack_eigs_step(arg1: "arpack_eigs_t *") -> "float **":
    return _yael.arpack_eigs_step(arg1)

def arpack_eigs_end(arg1: "arpack_eigs_t *", sout: "float *", vout: "float *") -> "int":
    return _yael.arpack_eigs_end(arg1, sout, vout)
class gmm_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    d = property(_yael.gmm_t_d_get, _yael.gmm_t_d_set)
    k = property(_yael.gmm_t_k_get, _yael.gmm_t_k_set)
    w = property(_yael.gmm_t_w_get, _yael.gmm_t_w_set)
    mu = property(_yael.gmm_t_mu_get, _yael.gmm_t_mu_set)
    sigma = property(_yael.gmm_t_sigma_get, _yael.gmm_t_sigma_set)

    def __init__(self):
        _yael.gmm_t_swiginit(self, _yael.new_gmm_t())
    __swig_destroy__ = _yael.delete_gmm_t

# Register gmm_t in _yael:
_yael.gmm_t_swigregister(gmm_t)

GMM_FLAGS_W = _yael.GMM_FLAGS_W
GMM_FLAGS_NO_NORM = _yael.GMM_FLAGS_NO_NORM
GMM_FLAGS_1SIGMA = _yael.GMM_FLAGS_1SIGMA
GMM_FLAGS_PURE_KMEANS = _yael.GMM_FLAGS_PURE_KMEANS
GMM_FLAGS_SIGMA = _yael.GMM_FLAGS_SIGMA
GMM_FLAGS_MU = _yael.GMM_FLAGS_MU

def gmm_learn(d: "int", n: "int", k: "int", niter: "int", v: "float const *", nt: "int", seed: "int", nredo: "int", flags: "int") -> "gmm_t *":
    return _yael.gmm_learn(d, n, k, niter, v, nt, seed, nredo, flags)

def gmm_print(g: "gmm_t") -> "void":
    return _yael.gmm_print(g)

def gmm_delete(g: "gmm_t") -> "void":
    return _yael.gmm_delete(g)

def gmm_compute_p(n: "int", v: "float const *", g: "gmm_t", p: "float *", flags: "int") -> "void":
    return _yael.gmm_compute_p(n, v, g, p, flags)

def gmm_fisher(n: "int", v: "float const *", g: "gmm_t", flags: "int", fisher_vector_out: "float *") -> "void":
    return _yael.gmm_fisher(n, v, g, flags, fisher_vector_out)

def gmm_fisher_from_posteriors(n: "int", v: "float const *", g: "gmm_t", flags: "int", p: "float const *", fisher_vector_out: "float *") -> "void":
    return _yael.gmm_fisher_from_posteriors(n, v, g, flags, p, fisher_vector_out)

def gmm_fisher_sizeof(g: "gmm_t", flags: "int") -> "size_t":
    return _yael.gmm_fisher_sizeof(g, flags)

def gmm_fisher_spatial(N: "int", K: "int", sd: "int", Q: "float const *", sgmm: "float const *", ll: "float const *", sdesc: "float *") -> "void":
    return _yael.gmm_fisher_spatial(N, K, sd, Q, sgmm, ll, sdesc)

def gmm_write(g: "gmm_t", f: "FILE *") -> "void":
    return _yael.gmm_write(g, f)

def gmm_read(f: "FILE *") -> "gmm_t *":
    return _yael.gmm_read(f)

def gmm_compute_p_thread(n: "int", v: "float const *", g: "gmm_t", p: "float *", flags: "int", n_thread: "int") -> "void":
    return _yael.gmm_compute_p_thread(n, v, g, p, flags, n_thread)

def vlad_compute(k: "int", d: "int", centroids: "float const *", n: "int", v: "float const *", desc: "float *") -> "void":
    return _yael.vlad_compute(k, d, centroids, n, v, desc)

def vlad_compute_weighted(k: "int", d: "int", centroids: "float const *", n: "int", v: "float const *", weights: "float const *", desc: "float *") -> "void":
    return _yael.vlad_compute_weighted(k, d, centroids, n, v, weights, desc)

def vlad_compute_subsets(k: "int", d: "int", centroids: "float const *", n: "int", v: "float const *", n_subset: "int", subset_indexes: "int const *", subset_ends: "int const *", desc: "float *") -> "void":
    return _yael.vlad_compute_subsets(k, d, centroids, n, v, n_subset, subset_indexes, subset_ends, desc)

def bof_compute(k: "int", d: "int", centroids: "float const *", n: "int", v: "float const *", desc: "int *") -> "void":
    return _yael.bof_compute(k, d, centroids, n, v, desc)

def bof_compute_ma(k: "int", d: "int", centroids: "float const *", n: "int", v: "float const *", desc: "int *", ma: "int", alpha: "float", nt: "int") -> "void":
    return _yael.bof_compute_ma(k, d, centroids, n, v, desc, ma, alpha, nt)

def bof_compute_subsets(k: "int", d: "int", centroids: "float const *", n: "int", v: "float const *", n_subset: "int", subset_indexes: "int const *", subset_ends: "int const *", desc: "float *") -> "void":
    return _yael.bof_compute_subsets(k, d, centroids, n, v, n_subset, subset_indexes, subset_ends, desc)
class nnlist_s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_yael.nnlist_s_n_get, _yael.nnlist_s_n_set)
    k = property(_yael.nnlist_s_k_get, _yael.nnlist_s_k_set)
    idx = property(_yael.nnlist_s_idx_get, _yael.nnlist_s_idx_set)
    dis = property(_yael.nnlist_s_dis_get, _yael.nnlist_s_dis_set)

    def __init__(self):
        _yael.nnlist_s_swiginit(self, _yael.new_nnlist_s())
    __swig_destroy__ = _yael.delete_nnlist_s

# Register nnlist_s in _yael:
_yael.nnlist_s_swigregister(nnlist_s)


def nnlist_new(n: "int", k: "int") -> "nnlist_t *":
    return _yael.nnlist_new(n, k)

def nnlist_new_noalloc(n: "int", k: "int") -> "nnlist_t *":
    return _yael.nnlist_new_noalloc(n, k)

def nnlist_delete(l: "nnlist_s") -> "void":
    return _yael.nnlist_delete(l)

def nnlist_addn(l: "nnlist_s", lno: "int", n: "int", idx: "int *", dis: "float *") -> "void":
    return _yael.nnlist_addn(l, lno, n, idx, dis)
KMLSH_NT = _yael.KMLSH_NT
KMLSH_QUIET = _yael.KMLSH_QUIET
KMLSH_WRITE_INTER_NHASH = _yael.KMLSH_WRITE_INTER_NHASH
KMLSH_BLOCK_SIZE = _yael.KMLSH_BLOCK_SIZE
KMLSH_NB_ITER_MAX = _yael.KMLSH_NB_ITER_MAX
KMLSH_VECTYPE_FVEC = _yael.KMLSH_VECTYPE_FVEC
KMLSH_VECTYPE_BVEC = _yael.KMLSH_VECTYPE_BVEC
class kmlsh_s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nhash = property(_yael.kmlsh_s_nhash_get, _yael.kmlsh_s_nhash_set)
    d = property(_yael.kmlsh_s_d_get, _yael.kmlsh_s_d_set)
    nclust = property(_yael.kmlsh_s_nclust_get, _yael.kmlsh_s_nclust_set)
    centroids = property(_yael.kmlsh_s_centroids_get, _yael.kmlsh_s_centroids_set)

    def __init__(self):
        _yael.kmlsh_s_swiginit(self, _yael.new_kmlsh_s())
    __swig_destroy__ = _yael.delete_kmlsh_s

# Register kmlsh_s in _yael:
_yael.kmlsh_s_swigregister(kmlsh_s)

class kmlsh_idx_s(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nhash = property(_yael.kmlsh_idx_s_nhash_get, _yael.kmlsh_idx_s_nhash_set)
    n = property(_yael.kmlsh_idx_s_n_get, _yael.kmlsh_idx_s_n_set)
    nclust = property(_yael.kmlsh_idx_s_nclust_get, _yael.kmlsh_idx_s_nclust_set)
    perm = property(_yael.kmlsh_idx_s_perm_get, _yael.kmlsh_idx_s_perm_set)
    boundaries = property(_yael.kmlsh_idx_s_boundaries_get, _yael.kmlsh_idx_s_boundaries_set)

    def __init__(self):
        _yael.kmlsh_idx_s_swiginit(self, _yael.new_kmlsh_idx_s())
    __swig_destroy__ = _yael.delete_kmlsh_idx_s

# Register kmlsh_idx_s in _yael:
_yael.kmlsh_idx_s_swigregister(kmlsh_idx_s)


def kmlsh_new(nhash: "int", nclust: "int", d: "int") -> "kmlsh_t *":
    return _yael.kmlsh_new(nhash, nclust, d)

def kmlsh_delete(lsh: "kmlsh_s") -> "void":
    return _yael.kmlsh_delete(lsh)

def kmlsh_learn_xvec(lsh: "kmlsh_s", n: "int", nlearn: "int", v: "void const *", flags: "int", vec_type: "int") -> "void":
    return _yael.kmlsh_learn_xvec(lsh, n, nlearn, v, flags, vec_type)

def kmlsh_new_learn_bvec(nhash: "int", nclust: "int", d: "int", n: "int", nlearn: "int", v: "unsigned char const *", flags: "int") -> "kmlsh_t *":
    return _yael.kmlsh_new_learn_bvec(nhash, nclust, d, n, nlearn, v, flags)

def kmlsh_new_learn_fvec(nhash: "int", nclust: "int", d: "int", n: "int", nlearn: "int", v: "float const *", flags: "int") -> "kmlsh_t *":
    return _yael.kmlsh_new_learn_fvec(nhash, nclust, d, n, nlearn, v, flags)

def kmlsh_match_xvec(lsh: "kmlsh_s", lshidx_b: "kmlsh_idx_s", vb: "void const *", nb: "int", lshidx_q: "kmlsh_idx_s", vq: "void const *", nq: "int", k: "int", nt: "int", vec_type: "int") -> "nnlist_t *":
    return _yael.kmlsh_match_xvec(lsh, lshidx_b, vb, nb, lshidx_q, vq, nq, k, nt, vec_type)

def kmlsh_match_bvec(lsh: "kmlsh_s", lshidx_b: "kmlsh_idx_s", vb: "unsigned char const *", nb: "int", lshidx_q: "kmlsh_idx_s", vq: "unsigned char const *", nq: "int", k: "int", nt: "int") -> "nnlist_t *":
    return _yael.kmlsh_match_bvec(lsh, lshidx_b, vb, nb, lshidx_q, vq, nq, k, nt)

def kmlsh_match_fvec(lsh: "kmlsh_s", lshidx_b: "kmlsh_idx_s", vb: "float const *", nb: "int", lshidx_q: "kmlsh_idx_s", vq: "float const *", nq: "int", k: "int", nt: "int") -> "nnlist_t *":
    return _yael.kmlsh_match_fvec(lsh, lshidx_b, vb, nb, lshidx_q, vq, nq, k, nt)

def kmlsh_ann_xvec(vb: "void const *", nb: "int", vq: "void const *", nq: "int", d: "int", k: "int", nhash: "int", flags: "int", vec_type: "int") -> "nnlist_t *":
    return _yael.kmlsh_ann_xvec(vb, nb, vq, nq, d, k, nhash, flags, vec_type)

def kmlsh_ann_bvec(vb: "unsigned char const *", nb: "int", vq: "unsigned char const *", nq: "int", d: "int", k: "int", nhash: "int", flags: "int") -> "nnlist_t *":
    return _yael.kmlsh_ann_bvec(vb, nb, vq, nq, d, k, nhash, flags)

def kmlsh_ann_fvec(vb: "float const *", nb: "int", vq: "float const *", nq: "int", d: "int", k: "int", nhash: "int", flags: "int") -> "nnlist_t *":
    return _yael.kmlsh_ann_fvec(vb, nb, vq, nq, d, k, nhash, flags)

def kmlsh_idx_new(lsh: "kmlsh_s", n: "int") -> "kmlsh_idx_t *":
    return _yael.kmlsh_idx_new(lsh, n)

def kmlsh_idx_delete(lshidx: "kmlsh_idx_s") -> "void":
    return _yael.kmlsh_idx_delete(lshidx)

def kmlsh_idx_new_compile_xvec(lsh: "kmlsh_s", v: "void const *", n: "int", flags: "int", vec_type: "int") -> "kmlsh_idx_t *":
    return _yael.kmlsh_idx_new_compile_xvec(lsh, v, n, flags, vec_type)

def kmlsh_idx_new_compile_bvec(lsh: "kmlsh_s", v: "unsigned char const *", n: "int", flags: "int") -> "kmlsh_idx_t *":
    return _yael.kmlsh_idx_new_compile_bvec(lsh, v, n, flags)

def kmlsh_idx_new_compile_fvec(lsh: "kmlsh_s", v: "float const *", n: "int", flags: "int") -> "kmlsh_idx_t *":
    return _yael.kmlsh_idx_new_compile_fvec(lsh, v, n, flags)

def kmlsh_idx_get_nvec(lshidx: "kmlsh_idx_s", h: "int", c: "int") -> "int":
    return _yael.kmlsh_idx_get_nvec(lshidx, h, c)

def kmlsh_idx_get_maxincell(lshidx: "kmlsh_idx_s", h: "int") -> "int":
    return _yael.kmlsh_idx_get_maxincell(lshidx, h)

def kmlsh_idx_get_vecids(lshidx: "kmlsh_idx_s", h: "int", c: "int") -> "int *":
    return _yael.kmlsh_idx_get_vecids(lshidx, h, c)

def kmeans_cohash_xvec(lsh: "kmlsh_s", h: "int", v: "void const *", n: "int", perm: "int *", boundaries: "int *", flags: "int", vec_type: "int") -> "void":
    return _yael.kmeans_cohash_xvec(lsh, h, v, n, perm, boundaries, flags, vec_type)

def kmeans_cohash_bvec(lsh: "kmlsh_s", h: "int", v: "unsigned char const *", n: "int", perm: "int *", boundaries: "int *", flags: "int") -> "void":
    return _yael.kmeans_cohash_bvec(lsh, h, v, n, perm, boundaries, flags)

def kmeans_cohash_fvec(lsh: "kmlsh_s", h: "int", v: "float const *", n: "int", perm: "int *", boundaries: "int *", flags: "int") -> "void":
    return _yael.kmeans_cohash_fvec(lsh, h, v, n, perm, boundaries, flags)

def kmlsh_write(filename: "char const *", lsh: "kmlsh_s") -> "void":
    return _yael.kmlsh_write(filename, lsh)

def kmlsh_read(filename: "char const *", lsh: "kmlsh_s") -> "void":
    return _yael.kmlsh_read(filename, lsh)

def kmlsh_idx_write(filename: "char const *", lshidx: "kmlsh_idx_s") -> "void":
    return _yael.kmlsh_idx_write(filename, lshidx)

def kmlsh_idx_read(filename: "char const *", lshidx: "kmlsh_idx_s") -> "void":
    return _yael.kmlsh_idx_read(filename, lshidx)
KEYNULL = _yael.KEYNULL
IVFCHECKSUM = _yael.IVFCHECKSUM
DEFAULT_SEG_SIZE = _yael.DEFAULT_SEG_SIZE
class ivf_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    checksum = property(_yael.ivf_t_checksum_get, _yael.ivf_t_checksum_set)
    k = property(_yael.ivf_t_k_get, _yael.ivf_t_k_set)
    n = property(_yael.ivf_t_n_get, _yael.ivf_t_n_set)
    elem_size = property(_yael.ivf_t_elem_size_get, _yael.ivf_t_elem_size_set)
    nbelems = property(_yael.ivf_t_nbelems_get, _yael.ivf_t_nbelems_set)
    seg_size = property(_yael.ivf_t_seg_size_get, _yael.ivf_t_seg_size_set)
    ids = property(_yael.ivf_t_ids_get, _yael.ivf_t_ids_set)
    adat = property(_yael.ivf_t_adat_get, _yael.ivf_t_adat_set)

    def __init__(self):
        _yael.ivf_t_swiginit(self, _yael.new_ivf_t())
    __swig_destroy__ = _yael.delete_ivf_t

# Register ivf_t in _yael:
_yael.ivf_t_swigregister(ivf_t)

class ivfmatch_t(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    qid = property(_yael.ivfmatch_t_qid_get, _yael.ivfmatch_t_qid_set)
    bid = property(_yael.ivfmatch_t_bid_get, _yael.ivfmatch_t_bid_set)
    score = property(_yael.ivfmatch_t_score_get, _yael.ivfmatch_t_score_set)

    def __init__(self):
        _yael.ivfmatch_t_swiginit(self, _yael.new_ivfmatch_t())
    __swig_destroy__ = _yael.delete_ivfmatch_t

# Register ivfmatch_t in _yael:
_yael.ivfmatch_t_swigregister(ivfmatch_t)


def ivf_checksum(ivf: "ivf_t") -> "int":
    return _yael.ivf_checksum(ivf)

def ivf_new(k: "int", elemsize: "int", segsize: "int") -> "ivf_t *":
    return _yael.ivf_new(k, elemsize, segsize)

def ivf_delete(ivf: "ivf_t") -> "void":
    return _yael.ivf_delete(ivf)

def ivf_addn(ivf: "ivf_t", id: "int const *", keys: "int const *", val: "unsigned char const *", n: "int") -> "void":
    return _yael.ivf_addn(ivf, id, keys, val, n)

def ivf_add(ivf: "ivf_t", id: "int", key: "int", val: "unsigned char const *") -> "void":
    return _yael.ivf_add(ivf, id, key, val)

def ivf_get_nb_elems(ivf: "ivf_t", key: "int") -> "int":
    return _yael.ivf_get_nb_elems(ivf, key)

def ivf_get_ids(ivf: "ivf_t", key: "int") -> "int *":
    return _yael.ivf_get_ids(ivf, key)

def ivf_get_vals(ivf: "ivf_t", key: "int") -> "unsigned char *":
    return _yael.ivf_get_vals(ivf, key)

def ivf_find_vals(ivf: "ivf_t", keys: "int *", ids: "int *", n: "int") -> "unsigned char *":
    return _yael.ivf_find_vals(ivf, keys, ids, n)

def ivf_display(ivf: "ivf_t") -> "void":
    return _yael.ivf_display(ivf)

def ivf_count_nbelems(ivf: "ivf_t") -> "int":
    return _yael.ivf_count_nbelems(ivf)

def ivf_imbalance_factor(ivf: "ivf_t") -> "double":
    return _yael.ivf_imbalance_factor(ivf)

def ivf_hequery(ivf: "ivf_t", qids: "int const *", keys: "int const *", adat: "unsigned char const *", nq: "int", buffer_size: "int *", ht: "int") -> "ivfmatch_t *":
    return _yael.ivf_hequery(ivf, qids, keys, adat, nq, buffer_size, ht)

def ivf_hequeryw(ivf: "ivf_t", qids: "int const *", keys: "int const *", adat: "unsigned char const *", nq: "int", ht: "int", nm: "size_t *", score_map_: "float const *", list_w_: "float const *") -> "ivfmatch_t *":
    return _yael.ivf_hequeryw(ivf, qids, keys, adat, nq, ht, nm, score_map_, list_w_)

def ivf_save(fname: "char const *", ivf: "ivf_t") -> "int":
    return _yael.ivf_save(fname, ivf)

def ivf_load(fname: "char const *") -> "ivf_t *":
    return _yael.ivf_load(fname)

def ivfmatch_new(n: "int") -> "ivfmatch_t *":
    return _yael.ivfmatch_new(n)

def ivf_he_collect_crossmatches(ivf: "ivf_t", ht: "int", nmatches: "size_t *") -> "hammatch_t **":
    return _yael.ivf_he_collect_crossmatches(ivf, ht, nmatches)

def ivf_he_count_crossmatches(ivf: "ivf_t", ht: "int", nmatches: "size_t *") -> "void":
    return _yael.ivf_he_count_crossmatches(ivf, ht, nmatches)

def ivf_he_crossmatches_prealloc(ivf: "ivf_t", ht: "int", idx: "int *", hams: "uint16 *", cumnmatches: "size_t *") -> "void":
    return _yael.ivf_he_crossmatches_prealloc(ivf, ht, idx, hams, cumnmatches)

def free(arg1: "void *") -> "void":
    return _yael.free(arg1)

def count_cpu() -> "int":
    return _yael.count_cpu()

def log2(x: "double") -> "double":
    return _yael.log2(x)

def memalign(ignored: "size_t", nbytes: "size_t") -> "void *":
    return _yael.memalign(ignored, nbytes)

def getmillisecs() -> "double":
    return _yael.getmillisecs()

def compute_tasks(n: "int", nthread: "int", task_fun: "void (*)(void *,int,int)", task_arg: "void *") -> "void":
    return _yael.compute_tasks(n, nthread, task_fun, task_arg)

def common_srandom(seed: "int") -> "void":
    return _yael.common_srandom(seed)

def bvec_to_numpy(src: "unsigned char const *", ndim: "int") -> "PyObject *":
    r"""
    bvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape with a copy bvec data.
    """
    return _yael.bvec_to_numpy(src, ndim)

def bvec_to_numpy_ref(src: "unsigned char *", ndim: "int") -> "PyObject *":
    r"""
    bvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to bvec data
     *without taking ownership of the memory* (you will have to free it manually).
    """
    return _yael.bvec_to_numpy_ref(src, ndim)

def bvec_to_numpy_acquire(src: "unsigned char *", ndim: "int") -> "PyObject *":
    r"""
    bvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to bvec data and 
     *takes ownership of the memory* (it will be freed by the GC when the ndarray isn't referenced anymore).
    """
    return _yael.bvec_to_numpy_acquire(src, ndim)

def numpy_to_bvec(di: "long") -> "unsigned char *":
    return _yael.numpy_to_bvec(di)

def numpy_to_bvec_ref(di: "long") -> "unsigned char *":
    return _yael.numpy_to_bvec_ref(di)

def fvec_to_numpy(src: "float const *", ndim: "int") -> "PyObject *":
    r"""
    fvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape with a copy fvec data.
    """
    return _yael.fvec_to_numpy(src, ndim)

def fvec_to_numpy_ref(src: "float *", ndim: "int") -> "PyObject *":
    r"""
    fvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to fvec data
     *without taking ownership of the memory* (you will have to free it manually).
    """
    return _yael.fvec_to_numpy_ref(src, ndim)

def fvec_to_numpy_acquire(src: "float *", ndim: "int") -> "PyObject *":
    r"""
    fvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to fvec data and 
     *takes ownership of the memory* (it will be freed by the GC when the ndarray isn't referenced anymore).
    """
    return _yael.fvec_to_numpy_acquire(src, ndim)

def numpy_to_fvec(di: "long") -> "float *":
    return _yael.numpy_to_fvec(di)

def numpy_to_fvec_ref(di: "long") -> "float *":
    return _yael.numpy_to_fvec_ref(di)

def ivec_to_numpy(src: "int const *", ndim: "int") -> "PyObject *":
    r"""
    ivec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape with a copy ivec data.
    """
    return _yael.ivec_to_numpy(src, ndim)

def ivec_to_numpy_ref(src: "int *", ndim: "int") -> "PyObject *":
    r"""
    ivec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to ivec data
     *without taking ownership of the memory* (you will have to free it manually).
    """
    return _yael.ivec_to_numpy_ref(src, ndim)

def ivec_to_numpy_acquire(src: "int *", ndim: "int") -> "PyObject *":
    r"""
    ivec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to ivec data and 
     *takes ownership of the memory* (it will be freed by the GC when the ndarray isn't referenced anymore).
    """
    return _yael.ivec_to_numpy_acquire(src, ndim)

def numpy_to_ivec(di: "long") -> "int *":
    return _yael.numpy_to_ivec(di)

def numpy_to_ivec_ref(di: "long") -> "int *":
    return _yael.numpy_to_ivec_ref(di)

def int16vec_to_numpy(src: "short const *", ndim: "int") -> "PyObject *":
    r"""
    int16vec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape with a copy int16vec data.
    """
    return _yael.int16vec_to_numpy(src, ndim)

def int16vec_to_numpy_ref(src: "short *", ndim: "int") -> "PyObject *":
    r"""
    int16vec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to int16vec data
     *without taking ownership of the memory* (you will have to free it manually).
    """
    return _yael.int16vec_to_numpy_ref(src, ndim)

def int16vec_to_numpy_acquire(src: "short *", ndim: "int") -> "PyObject *":
    r"""
    int16vec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to int16vec data and 
     *takes ownership of the memory* (it will be freed by the GC when the ndarray isn't referenced anymore).
    """
    return _yael.int16vec_to_numpy_acquire(src, ndim)

def numpy_to_int16vec(di: "long") -> "short *":
    return _yael.numpy_to_int16vec(di)

def numpy_to_int16vec_ref(di: "long") -> "short *":
    return _yael.numpy_to_int16vec_ref(di)

def uint16vec_to_numpy(src: "unsigned short const *", ndim: "int") -> "PyObject *":
    r"""
    uint16vec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape with a copy uint16vec data.
    """
    return _yael.uint16vec_to_numpy(src, ndim)

def uint16vec_to_numpy_ref(src: "unsigned short *", ndim: "int") -> "PyObject *":
    r"""
    uint16vec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to uint16vec data
     *without taking ownership of the memory* (you will have to free it manually).
    """
    return _yael.uint16vec_to_numpy_ref(src, ndim)

def uint16vec_to_numpy_acquire(src: "unsigned short *", ndim: "int") -> "PyObject *":
    r"""
    uint16vec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to uint16vec data and 
     *takes ownership of the memory* (it will be freed by the GC when the ndarray isn't referenced anymore).
    """
    return _yael.uint16vec_to_numpy_acquire(src, ndim)

def numpy_to_uint16vec(di: "long") -> "unsigned short *":
    return _yael.numpy_to_uint16vec(di)

def numpy_to_uint16vec_ref(di: "long") -> "unsigned short *":
    return _yael.numpy_to_uint16vec_ref(di)

def dvec_to_numpy(src: "double const *", ndim: "int") -> "PyObject *":
    r"""
    dvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape with a copy dvec data.
    """
    return _yael.dvec_to_numpy(src, ndim)

def dvec_to_numpy_ref(src: "double *", ndim: "int") -> "PyObject *":
    r"""
    dvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to dvec data
     *without taking ownership of the memory* (you will have to free it manually).
    """
    return _yael.dvec_to_numpy_ref(src, ndim)

def dvec_to_numpy_acquire(src: "double *", ndim: "int") -> "PyObject *":
    r"""
    dvec _to_numpy(src, shape) -> numpy.ndarray
     shape can be an integer or a tuple of integers (maximum 8 dimentions)
     Creates a new ndarray of specified shape pointing to dvec data and 
     *takes ownership of the memory* (it will be freed by the GC when the ndarray isn't referenced anymore).
    """
    return _yael.dvec_to_numpy_acquire(src, ndim)

def numpy_to_dvec(di: "long") -> "double *":
    return _yael.numpy_to_dvec(di)

def numpy_to_dvec_ref(di: "long") -> "double *":
    return _yael.numpy_to_dvec_ref(di)


